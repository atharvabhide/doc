

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>librosa.core.spectrum &mdash; librosa 0.6.3 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-dataframe.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/librosa_logo_text.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core.html">Core IO and DSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../display.html">Display</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../feature.html">Feature extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../onset.html">Onset detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../beat.html">Beat and tempo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../decompose.html">Spectrogram decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../effects.html">Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../output.html">Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../segment.html">Temporal segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sequence.html">Sequential modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../util.html">Utilities</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../filters.html">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cache.html">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ioformats.html">Advanced I/O Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../advanced.html">Advanced examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">librosa</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>librosa.core.spectrum</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for librosa.core.spectrum</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&#39;&#39;&#39;Utilities for spectral processing&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.fftpack</span> <span class="k">as</span> <span class="nn">fft</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span>
<span class="kn">import</span> <span class="nn">six</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">time_frequency</span>
<span class="kn">from</span> <span class="nn">.audio</span> <span class="kn">import</span> <span class="n">resample</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">..util.exceptions</span> <span class="kn">import</span> <span class="n">ParameterError</span>
<span class="kn">from</span> <span class="nn">..filters</span> <span class="kn">import</span> <span class="n">get_window</span><span class="p">,</span> <span class="n">semitone_filterbank</span>
<span class="kn">from</span> <span class="nn">..filters</span> <span class="kn">import</span> <span class="n">window_sumsquare</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;stft&#39;</span><span class="p">,</span> <span class="s1">&#39;istft&#39;</span><span class="p">,</span> <span class="s1">&#39;magphase&#39;</span><span class="p">,</span> <span class="s1">&#39;iirt&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ifgram&#39;</span><span class="p">,</span> <span class="s1">&#39;phase_vocoder&#39;</span><span class="p">,</span>
           <span class="s1">&#39;perceptual_weighting&#39;</span><span class="p">,</span>
           <span class="s1">&#39;power_to_db&#39;</span><span class="p">,</span> <span class="s1">&#39;db_to_power&#39;</span><span class="p">,</span>
           <span class="s1">&#39;amplitude_to_db&#39;</span><span class="p">,</span> <span class="s1">&#39;db_to_amplitude&#39;</span><span class="p">,</span>
           <span class="s1">&#39;fmt&#39;</span><span class="p">,</span> <span class="s1">&#39;pcen&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="stft"><a class="viewcode-back" href="../../../generated/librosa.core.stft.html#librosa.core.stft">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span>
         <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Short-time Fourier transform (STFT)</span>

<span class="sd">    Returns a complex-valued matrix D such that</span>
<span class="sd">        `np.abs(D[f, t])` is the magnitude of frequency bin `f`</span>
<span class="sd">        at frame `t`</span>

<span class="sd">        `np.angle(D[f, t])` is the phase of frequency bin `f`</span>
<span class="sd">        at frame `t`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)], real-valued</span>
<span class="sd">        the input signal (audio time series)</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        number audio of frames between STFT columns.</span>
<span class="sd">        If unspecified, defaults `win_length / 4`.</span>

<span class="sd">    win_length  : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length `win_length` and then padded</span>
<span class="sd">        with zeros to match `n_fft`.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a vector or array of length `n_fft`</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center      : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">          `D[:, t]` is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then `D[:, t]` begins at `y[t * hop_length]`</span>

<span class="sd">    dtype       : numeric type</span>
<span class="sd">        Complex numeric type for `D`.  Default is 64-bit complex.</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses reflection padding.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D : np.ndarray [shape=(1 + n_fft/2, t), dtype=dtype]</span>
<span class="sd">        STFT matrix</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    istft : Inverse STFT</span>

<span class="sd">    ifgram : Instantaneous frequency spectrogram</span>

<span class="sd">    np.pad : array padding</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 20.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; D = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; D</span>
<span class="sd">    array([[2.58028018e-03, 4.32422794e-02, 6.61255598e-01, ...,</span>
<span class="sd">            6.82710262e-04, 2.51654536e-04, 7.23036574e-05],</span>
<span class="sd">           [2.49403086e-03, 5.15930466e-02, 6.00107312e-01, ...,</span>
<span class="sd">            3.48026224e-04, 2.35853557e-04, 7.54836728e-05],</span>
<span class="sd">           [7.82410789e-04, 1.05394892e-01, 4.37517226e-01, ...,</span>
<span class="sd">            6.29352580e-04, 3.38571583e-04, 8.38094638e-05],</span>
<span class="sd">           ...,</span>
<span class="sd">           [9.48568513e-08, 4.74725084e-07, 1.50052492e-05, ...,</span>
<span class="sd">            1.85637656e-08, 2.89708542e-08, 5.74304337e-09],</span>
<span class="sd">           [1.25165826e-07, 8.58259284e-07, 1.11157215e-05, ...,</span>
<span class="sd">            3.49099771e-08, 3.11740926e-08, 5.29926236e-09],</span>
<span class="sd">           [1.70630571e-07, 8.92518756e-07, 1.23656537e-05, ...,</span>
<span class="sd">            5.33256745e-08, 3.33264900e-08, 5.13272980e-09]], dtype=float32)</span>


<span class="sd">    Use left-aligned frames, instead of centered frames</span>

<span class="sd">    &gt;&gt;&gt; D_left = np.abs(librosa.stft(y, center=False))</span>


<span class="sd">    Use a shorter hop length</span>

<span class="sd">    &gt;&gt;&gt; D_short = np.abs(librosa.stft(y, hop_length=64))</span>


<span class="sd">    Display a spectrogram</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(D,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># By default, use the entire frame</span>
    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="c1"># Set the default hop, if it&#39;s not already specified</span>
    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="n">fft_window</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">win_length</span><span class="p">,</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Pad the window out to n_fft size</span>
    <span class="n">fft_window</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">fft_window</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">)</span>

    <span class="c1"># Reshape so that the window can be broadcast</span>
    <span class="n">fft_window</span> <span class="o">=</span> <span class="n">fft_window</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Check audio is valid</span>
    <span class="n">util</span><span class="o">.</span><span class="n">valid_audio</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="c1"># Pad the time series so that frames are centered</span>
    <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

    <span class="c1"># Window the time series.</span>
    <span class="n">y_frames</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">frame</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">frame_length</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>

    <span class="c1"># Pre-allocate the STFT matrix</span>
    <span class="n">stft_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">y_frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                           <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="c1"># how many columns can we fit within MAX_MEM_BLOCK?</span>
    <span class="n">n_columns</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">MAX_MEM_BLOCK</span> <span class="o">/</span> <span class="p">(</span><span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
                                          <span class="n">stft_matrix</span><span class="o">.</span><span class="n">itemsize</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">bl_s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_columns</span><span class="p">):</span>
        <span class="n">bl_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bl_s</span> <span class="o">+</span> <span class="n">n_columns</span><span class="p">,</span> <span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">stft_matrix</span><span class="p">[:,</span> <span class="n">bl_s</span><span class="p">:</span><span class="n">bl_t</span><span class="p">]</span> <span class="o">=</span> <span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">fft_window</span> <span class="o">*</span>
                                            <span class="n">y_frames</span><span class="p">[:,</span> <span class="n">bl_s</span><span class="p">:</span><span class="n">bl_t</span><span class="p">],</span>
                                            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:</span><span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">stft_matrix</span></div>


<div class="viewcode-block" id="istft"><a class="viewcode-back" href="../../../generated/librosa.core.istft.html#librosa.core.istft">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">istft</span><span class="p">(</span><span class="n">stft_matrix</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span>
          <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverse short-time Fourier transform (ISTFT).</span>

<span class="sd">    Converts a complex-valued spectrogram `stft_matrix` to time-series `y`</span>
<span class="sd">    by minimizing the mean squared error between `stft_matrix` and STFT of</span>
<span class="sd">    `y` as described in [1]_ up to Section 2 (reconstruction from MSTFT).</span>

<span class="sd">    In general, window function, hop length and other parameters should be same</span>
<span class="sd">    as in stft, which mostly leads to perfect reconstruction of a signal from</span>
<span class="sd">    unmodified `stft_matrix`.</span>

<span class="sd">    .. [1] D. W. Griffin and J. S. Lim,</span>
<span class="sd">        &quot;Signal estimation from modified short-time Fourier transform,&quot;</span>
<span class="sd">        IEEE Trans. ASSP, vol.32, no.2, pp.236–243, Apr. 1984.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    stft_matrix : np.ndarray [shape=(1 + n_fft/2, t)]</span>
<span class="sd">        STFT matrix from `stft`</span>

<span class="sd">    hop_length  : int &gt; 0 [scalar]</span>
<span class="sd">        Number of frames between STFT columns.</span>
<span class="sd">        If unspecified, defaults to `win_length / 4`.</span>

<span class="sd">    win_length  : int &lt;= n_fft = 2 * (stft_matrix.shape[0] - 1)</span>
<span class="sd">        When reconstructing the time series, each frame is windowed</span>
<span class="sd">        and each sample is normalized by the sum of squared window</span>
<span class="sd">        according to the `window` function (see below).</span>

<span class="sd">        If unspecified, defaults to `n_fft`.</span>

<span class="sd">    window      : string, tuple, number, function, np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a user-specified window vector of length `n_fft`</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center      : boolean</span>
<span class="sd">        - If `True`, `D` is assumed to have centered frames.</span>
<span class="sd">        - If `False`, `D` is assumed to have left-aligned frames.</span>

<span class="sd">    dtype       : numeric type</span>
<span class="sd">        Real numeric type for `y`.  Default is 32-bit float.</span>

<span class="sd">    length : int &gt; 0, optional</span>
<span class="sd">        If provided, the output `y` is zero-padded or clipped to exactly</span>
<span class="sd">        `length` samples.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : np.ndarray [shape=(n,)]</span>
<span class="sd">        time domain signal reconstructed from `stft_matrix`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    stft : Short-time Fourier Transform</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; D = librosa.stft(y)</span>
<span class="sd">    &gt;&gt;&gt; y_hat = librosa.istft(D)</span>
<span class="sd">    &gt;&gt;&gt; y_hat</span>
<span class="sd">    array([ -4.812e-06,  -4.267e-06, ...,   6.271e-06,   2.827e-07], dtype=float32)</span>

<span class="sd">    Exactly preserving length of the input signal requires explicit padding.</span>
<span class="sd">    Otherwise, a partial frame at the end of `y` will not be represented.</span>

<span class="sd">    &gt;&gt;&gt; n = len(y)</span>
<span class="sd">    &gt;&gt;&gt; n_fft = 2048</span>
<span class="sd">    &gt;&gt;&gt; y_pad = librosa.util.fix_length(y, n + n_fft // 2)</span>
<span class="sd">    &gt;&gt;&gt; D = librosa.stft(y_pad, n_fft=n_fft)</span>
<span class="sd">    &gt;&gt;&gt; y_out = librosa.istft(D, length=n)</span>
<span class="sd">    &gt;&gt;&gt; np.max(np.abs(y - y_out))</span>
<span class="sd">    1.4901161e-07</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_fft</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># By default, use the entire frame</span>
    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="c1"># Set the default hop, if it&#39;s not already specified</span>
    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="n">ifft_window</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">win_length</span><span class="p">,</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Pad out to match n_fft</span>
    <span class="n">ifft_window</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">ifft_window</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">)</span>

    <span class="n">n_frames</span> <span class="o">=</span> <span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">expected_signal_len</span> <span class="o">=</span> <span class="n">n_fft</span> <span class="o">+</span> <span class="n">hop_length</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_frames</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">expected_signal_len</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_frames</span><span class="p">):</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">hop_length</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">stft_matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">spec</span><span class="p">,</span> <span class="n">spec</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ytmp</span> <span class="o">=</span> <span class="n">ifft_window</span> <span class="o">*</span> <span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>

        <span class="n">y</span><span class="p">[</span><span class="n">sample</span><span class="p">:(</span><span class="n">sample</span> <span class="o">+</span> <span class="n">n_fft</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">sample</span><span class="p">:(</span><span class="n">sample</span> <span class="o">+</span> <span class="n">n_fft</span><span class="p">)]</span> <span class="o">+</span> <span class="n">ytmp</span>

    <span class="c1"># Normalize by sum of squared window</span>
    <span class="n">ifft_window_sum</span> <span class="o">=</span> <span class="n">window_sumsquare</span><span class="p">(</span><span class="n">window</span><span class="p">,</span>
                                       <span class="n">n_frames</span><span class="p">,</span>
                                       <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
                                       <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
                                       <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                                       <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">approx_nonzero_indices</span> <span class="o">=</span> <span class="n">ifft_window_sum</span> <span class="o">&gt;</span> <span class="n">util</span><span class="o">.</span><span class="n">tiny</span><span class="p">(</span><span class="n">ifft_window_sum</span><span class="p">)</span>
    <span class="n">y</span><span class="p">[</span><span class="n">approx_nonzero_indices</span><span class="p">]</span> <span class="o">/=</span> <span class="n">ifft_window_sum</span><span class="p">[</span><span class="n">approx_nonzero_indices</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If we don&#39;t need to control length, just do the usual center trimming</span>
        <span class="c1"># to eliminate padded data</span>
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="c1"># If we&#39;re centering, crop off the first n_fft//2 samples</span>
            <span class="c1"># and then trim/pad to the target length.</span>
            <span class="c1"># We don&#39;t trim the end here, so that if the signal is zero-padded</span>
            <span class="c1"># to a longer duration, the decay is smooth by windowing</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If we&#39;re not centering, start at 0 and trim/pad as necessary</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">fix_length</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">start</span><span class="p">:],</span> <span class="n">length</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">y</span></div>


<div class="viewcode-block" id="ifgram"><a class="viewcode-back" href="../../../generated/librosa.core.ifgram.html#librosa.core.ifgram">[docs]</a><span class="k">def</span> <span class="nf">ifgram</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
           <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ref_power</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
           <span class="n">clip</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute the instantaneous frequency (as a proportion of the sampling rate)</span>
<span class="sd">    obtained as the time-derivative of the phase of the complex spectrum as</span>
<span class="sd">    described by [1]_.</span>

<span class="sd">    Calculates regular STFT as a side effect.</span>

<span class="sd">    .. [1] Abe, Toshihiko, Takao Kobayashi, and Satoshi Imai.</span>
<span class="sd">        &quot;Harmonics tracking and pitch extraction based on instantaneous</span>
<span class="sd">        frequency.&quot;</span>
<span class="sd">        International Conference on Acoustics, Speech, and Signal Processing,</span>
<span class="sd">        ICASSP-95., Vol. 1. IEEE, 1995.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)]</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length, number samples between subsequent frames.</span>
<span class="sd">        If not supplied, defaults to `win_length / 4`.</span>

<span class="sd">    win_length : int &gt; 0, &lt;= n_fft</span>
<span class="sd">        Window length. Defaults to `n_fft`.</span>
<span class="sd">        See `stft` for details.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a user-specified window vector of length `n_fft`</span>

<span class="sd">        See `stft` for details.</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    norm : bool</span>
<span class="sd">        Normalize the STFT.</span>

<span class="sd">    center      : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">            `D[:, t]` (and `if_gram`) is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then `D[:, t]` at `y[t * hop_length]`</span>

<span class="sd">    ref_power : float &gt;= 0 or callable</span>
<span class="sd">        Minimum power threshold for estimating instantaneous frequency.</span>
<span class="sd">        Any bin with `np.abs(D[f, t])**2 &lt; ref_power` will receive the</span>
<span class="sd">        default frequency estimate.</span>

<span class="sd">        If callable, the threshold is set to `ref_power(np.abs(D)**2)`.</span>

<span class="sd">    clip : boolean</span>
<span class="sd">        - If `True`, clip estimated frequencies to the range `[0, 0.5 * sr]`.</span>
<span class="sd">        - If `False`, estimated frequencies can be negative or exceed</span>
<span class="sd">          `0.5 * sr`.</span>

<span class="sd">    dtype : numeric type</span>
<span class="sd">        Complex numeric type for `D`.  Default is 64-bit complex.</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses reflection padding.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    if_gram : np.ndarray [shape=(1 + n_fft/2, t), dtype=real]</span>
<span class="sd">        Instantaneous frequency spectrogram:</span>
<span class="sd">        `if_gram[f, t]` is the frequency at bin `f`, time `t`</span>

<span class="sd">    D : np.ndarray [shape=(1 + n_fft/2, t), dtype=complex]</span>
<span class="sd">        Short-time Fourier transform</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    stft : Short-time Fourier Transform</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; frequencies, D = librosa.ifgram(y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; frequencies</span>
<span class="sd">    array([[  0.000e+00,   0.000e+00, ...,   0.000e+00,   0.000e+00],</span>
<span class="sd">           [  3.150e+01,   3.070e+01, ...,   1.077e+01,   1.077e+01],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  1.101e+04,   1.101e+04, ...,   1.101e+04,   1.101e+04],</span>
<span class="sd">           [  1.102e+04,   1.102e+04, ...,   1.102e+04,   1.102e+04]])</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Construct a padded hann window</span>
    <span class="n">fft_window</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">win_length</span><span class="p">,</span>
                                            <span class="n">fftbins</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                                 <span class="n">n_fft</span><span class="p">)</span>

    <span class="c1"># Window for discrete differentiation</span>
    <span class="n">freq_angular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">d_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">freq_angular</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">n_fft</span>

    <span class="n">stft_matrix</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                       <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
                       <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                       <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

    <span class="n">diff_stft</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                     <span class="n">window</span><span class="o">=</span><span class="n">d_window</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                     <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

    <span class="c1"># Compute power normalization. Suppress zeros.</span>
    <span class="n">mag</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">magphase</span><span class="p">(</span><span class="n">stft_matrix</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">ref_power</span><span class="p">):</span>
        <span class="n">ref_power</span> <span class="o">=</span> <span class="n">ref_power</span><span class="p">(</span><span class="n">mag</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ref_power</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;ref_power must be non-negative or callable.&#39;</span><span class="p">)</span>

    <span class="c1"># Pylint does not correctly infer the type here, but it&#39;s correct.</span>
    <span class="c1"># pylint: disable=maybe-no-member</span>
    <span class="n">freq_angular</span> <span class="o">=</span> <span class="n">freq_angular</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">bin_offset</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">phase</span> <span class="o">*</span> <span class="n">diff_stft</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">mag</span>

    <span class="n">bin_offset</span><span class="p">[</span><span class="n">mag</span> <span class="o">&lt;</span> <span class="n">ref_power</span><span class="o">**</span><span class="mf">0.5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">if_gram</span> <span class="o">=</span> <span class="n">freq_angular</span><span class="p">[:</span><span class="n">n_fft</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bin_offset</span>

    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
        <span class="n">stft_matrix</span> <span class="o">=</span> <span class="n">stft_matrix</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">fft_window</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">if_gram</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">if_gram</span><span class="p">)</span>

    <span class="n">if_gram</span> <span class="o">*=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sr</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="k">return</span> <span class="n">if_gram</span><span class="p">,</span> <span class="n">stft_matrix</span></div>


<div class="viewcode-block" id="magphase"><a class="viewcode-back" href="../../../generated/librosa.core.magphase.html#librosa.core.magphase">[docs]</a><span class="k">def</span> <span class="nf">magphase</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Separate a complex-valued spectrogram D into its magnitude (S)</span>
<span class="sd">    and phase (P) components, so that `D = S * P`.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D       : np.ndarray [shape=(d, t), dtype=complex]</span>
<span class="sd">        complex-valued spectrogram</span>
<span class="sd">    power : float &gt; 0</span>
<span class="sd">        Exponent for the magnitude spectrogram,</span>
<span class="sd">        e.g., 1 for energy, 2 for power, etc.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D_mag   : np.ndarray [shape=(d, t), dtype=real]</span>
<span class="sd">        magnitude of `D`, raised to `power`</span>
<span class="sd">    D_phase : np.ndarray [shape=(d, t), dtype=complex]</span>
<span class="sd">        `exp(1.j * phi)` where `phi` is the phase of `D`</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; D = librosa.stft(y)</span>
<span class="sd">    &gt;&gt;&gt; magnitude, phase = librosa.magphase(D)</span>
<span class="sd">    &gt;&gt;&gt; magnitude</span>
<span class="sd">    array([[  2.524e-03,   4.329e-02, ...,   3.217e-04,   3.520e-05],</span>
<span class="sd">           [  2.645e-03,   5.152e-02, ...,   3.283e-04,   3.432e-04],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  1.966e-05,   9.828e-06, ...,   3.164e-07,   9.370e-06],</span>
<span class="sd">           [  1.966e-05,   9.830e-06, ...,   3.161e-07,   9.366e-06]], dtype=float32)</span>
<span class="sd">    &gt;&gt;&gt; phase</span>
<span class="sd">    array([[  1.000e+00 +0.000e+00j,   1.000e+00 +0.000e+00j, ...,</span>
<span class="sd">             -1.000e+00 +8.742e-08j,  -1.000e+00 +8.742e-08j],</span>
<span class="sd">           [  1.000e+00 +1.615e-16j,   9.950e-01 -1.001e-01j, ...,</span>
<span class="sd">              9.794e-01 +2.017e-01j,   1.492e-02 -9.999e-01j],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  1.000e+00 -5.609e-15j,  -5.081e-04 +1.000e+00j, ...,</span>
<span class="sd">             -9.549e-01 -2.970e-01j,   2.938e-01 -9.559e-01j],</span>
<span class="sd">           [ -1.000e+00 +8.742e-08j,  -1.000e+00 +8.742e-08j, ...,</span>
<span class="sd">             -1.000e+00 +8.742e-08j,  -1.000e+00 +8.742e-08j]], dtype=complex64)</span>


<span class="sd">    Or get the phase angle (in radians)</span>

<span class="sd">    &gt;&gt;&gt; np.angle(phase)</span>
<span class="sd">    array([[  0.000e+00,   0.000e+00, ...,   3.142e+00,   3.142e+00],</span>
<span class="sd">           [  1.615e-16,  -1.003e-01, ...,   2.031e-01,  -1.556e+00],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ -5.609e-15,   1.571e+00, ...,  -2.840e+00,  -1.273e+00],</span>
<span class="sd">           [  3.142e+00,   3.142e+00, ...,   3.142e+00,   3.142e+00]], dtype=float32)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
    <span class="n">mag</span> <span class="o">**=</span> <span class="n">power</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">mag</span><span class="p">,</span> <span class="n">phase</span></div>


<div class="viewcode-block" id="phase_vocoder"><a class="viewcode-back" href="../../../generated/librosa.core.phase_vocoder.html#librosa.core.phase_vocoder">[docs]</a><span class="k">def</span> <span class="nf">phase_vocoder</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Phase vocoder.  Given an STFT matrix D, speed up by a factor of `rate`</span>

<span class="sd">    Based on the implementation provided by [1]_.</span>

<span class="sd">    .. [1] Ellis, D. P. W. &quot;A phase vocoder in Matlab.&quot;</span>
<span class="sd">        Columbia University, 2002.</span>
<span class="sd">        http://www.ee.columbia.edu/~dpwe/resources/matlab/pvoc/</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Play at double speed</span>
<span class="sd">    &gt;&gt;&gt; y, sr   = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; D       = librosa.stft(y, n_fft=2048, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; D_fast  = librosa.phase_vocoder(D, 2.0, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; y_fast  = librosa.istft(D_fast, hop_length=512)</span>

<span class="sd">    &gt;&gt;&gt; # Or play at 1/3 speed</span>
<span class="sd">    &gt;&gt;&gt; y, sr   = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; D       = librosa.stft(y, n_fft=2048, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; D_slow  = librosa.phase_vocoder(D, 1./3, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; y_slow  = librosa.istft(D_slow, hop_length=512)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D : np.ndarray [shape=(d, t), dtype=complex]</span>
<span class="sd">        STFT matrix</span>

<span class="sd">    rate :  float &gt; 0 [scalar]</span>
<span class="sd">        Speed-up factor: `rate &gt; 1` is faster, `rate &lt; 1` is slower.</span>

<span class="sd">    hop_length : int &gt; 0 [scalar] or None</span>
<span class="sd">        The number of samples between successive columns of `D`.</span>

<span class="sd">        If None, defaults to `n_fft/4 = (D.shape[0]-1)/2`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D_stretched  : np.ndarray [shape=(d, t / rate), dtype=complex]</span>
<span class="sd">        time-stretched STFT</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_fft</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="n">time_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rate</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="c1"># Create an empty output array</span>
    <span class="n">d_stretch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_steps</span><span class="p">)),</span> <span class="n">D</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="c1"># Expected phase advance in each bin</span>
    <span class="n">phi_advance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">hop_length</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Phase accumulator; initialize to the first sample</span>
    <span class="n">phase_acc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Pad 0 columns to simplify boundary logic</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time_steps</span><span class="p">):</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="n">D</span><span class="p">[:,</span> <span class="nb">int</span><span class="p">(</span><span class="n">step</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="n">step</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)]</span>

        <span class="c1"># Weighting for linear magnitude interpolation</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">columns</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
               <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">columns</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># Store to output array</span>
        <span class="n">d_stretch</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">mag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_acc</span><span class="p">)</span>

        <span class="c1"># Compute phase advance</span>
        <span class="n">dphase</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">columns</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                  <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">columns</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
                  <span class="o">-</span> <span class="n">phi_advance</span><span class="p">)</span>

        <span class="c1"># Wrap to -pi:pi range</span>
        <span class="n">dphase</span> <span class="o">=</span> <span class="n">dphase</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">dphase</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>

        <span class="c1"># Accumulate phase</span>
        <span class="n">phase_acc</span> <span class="o">+=</span> <span class="n">phi_advance</span> <span class="o">+</span> <span class="n">dphase</span>

    <span class="k">return</span> <span class="n">d_stretch</span></div>


<div class="viewcode-block" id="iirt"><a class="viewcode-back" href="../../../generated/librosa.core.iirt.html#librosa.core.iirt">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">iirt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
         <span class="n">tuning</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="n">flayout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Time-frequency representation using IIR filters [1]_.</span>

<span class="sd">    This function will return a time-frequency representation</span>
<span class="sd">    using a multirate filter bank consisting of IIR filters.</span>
<span class="sd">    First, `y` is resampled as needed according to the provided `sample_rates`.</span>
<span class="sd">    Then, a filterbank with with `n` band-pass filters is designed.</span>
<span class="sd">    The resampled input signals are processed by the filterbank as a whole.</span>
<span class="sd">    (`scipy.signal.filtfilt` resp. `sosfiltfilt` is used to make the phase linear.)</span>
<span class="sd">    The output of the filterbank is cut into frames.</span>
<span class="sd">    For each band, the short-time mean-square power (STMSP) is calculated by</span>
<span class="sd">    summing `win_length` subsequent filtered time samples.</span>

<span class="sd">    When called with the default set of parameters, it will generate the TF-representation</span>
<span class="sd">    as described in [1]_ (pitch filterbank):</span>

<span class="sd">        * 85 filters with MIDI pitches [24, 108] as `center_freqs`.</span>
<span class="sd">        * each filter having a bandwith of one semitone.</span>

<span class="sd">    .. [1] Müller, Meinard.</span>
<span class="sd">           &quot;Information Retrieval for Music and Motion.&quot;</span>
<span class="sd">           Springer Verlag. 2007.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)]</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    win_length : int &gt; 0, &lt;= n_fft</span>
<span class="sd">        Window length.</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        Hop length, number samples between subsequent frames.</span>
<span class="sd">        If not supplied, defaults to `win_length / 4`.</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">          `D[:, t]` is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then `D[:, t]` begins at `y[t * hop_length]`</span>

<span class="sd">    tuning : float in `[-0.5, +0.5)` [scalar]</span>
<span class="sd">        Tuning deviation from A440 in fractions of a bin.</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, this function uses reflection padding.</span>

<span class="sd">    flayout : string</span>
<span class="sd">        - If `ba`, the standard difference equation is used for filtering with `scipy.signal.filtfilt`.</span>
<span class="sd">          Can be unstable for high-order filters.</span>
<span class="sd">        - If `sos`, a series of second-order filters is used for filtering with `scipy.signal.sosfiltfilt`.</span>
<span class="sd">          Minimizes numerical precision errors for high-order filters, but is slower.</span>

<span class="sd">    kwargs : additional keyword arguments</span>
<span class="sd">        Additional arguments for `librosa.filters.semitone_filterbank()`</span>
<span class="sd">        (e.g., could be used to provide another set of `center_freqs` and `sample_rates`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bands_power : np.ndarray [shape=(n, t), dtype=dtype]</span>
<span class="sd">        Short-time mean-square power for the input signal.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If `flayout` is not None, `ba`, or `sos`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.filters.semitone_filterbank</span>
<span class="sd">    librosa.filters._multirate_fb</span>
<span class="sd">    librosa.filters.mr_frequencies</span>
<span class="sd">    librosa.core.cqt</span>
<span class="sd">    scipy.signal.filtfilt</span>
<span class="sd">    scipy.signal.sosfiltfilt</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; D = np.abs(librosa.iirt(y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(D, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;cqt_hz&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Semitone spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">flayout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Default filter layout for `iirt` is `ba`, but will be `sos` in 0.7.&#39;</span><span class="p">,</span>
                      <span class="ne">FutureWarning</span><span class="p">)</span>
        <span class="n">flayout</span> <span class="o">=</span> <span class="s1">&#39;ba&#39;</span>

    <span class="k">elif</span> <span class="n">flayout</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ba&#39;</span><span class="p">,</span> <span class="s1">&#39;sos&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Unsupported flayout=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">flayout</span><span class="p">))</span>

    <span class="c1"># check audio input</span>
    <span class="n">util</span><span class="o">.</span><span class="n">valid_audio</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="c1"># Set the default hop, if it&#39;s not already specified</span>
    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Pad the time series so that frames are centered</span>
    <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">hop_length</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

    <span class="c1"># get the semitone filterbank</span>
    <span class="n">filterbank_ct</span><span class="p">,</span> <span class="n">sample_rates</span> <span class="o">=</span> <span class="n">semitone_filterbank</span><span class="p">(</span><span class="n">tuning</span><span class="o">=</span><span class="n">tuning</span><span class="p">,</span> <span class="n">flayout</span><span class="o">=</span><span class="n">flayout</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># create three downsampled versions of the audio signal</span>
    <span class="n">y_resampled</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">y_srs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sample_rates</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">cur_sr</span> <span class="ow">in</span> <span class="n">y_srs</span><span class="p">:</span>
        <span class="n">y_resampled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resample</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">cur_sr</span><span class="p">))</span>

    <span class="c1"># Compute the number of frames that will fit. The end may get truncated.</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">win_length</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">hop_length</span><span class="p">))</span>

    <span class="n">bands_power</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">cur_sr</span><span class="p">,</span> <span class="n">cur_filter</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sample_rates</span><span class="p">,</span> <span class="n">filterbank_ct</span><span class="p">):</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sr</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">cur_sr</span><span class="p">)</span>
        <span class="n">win_length_STMSP</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">win_length</span> <span class="o">/</span> <span class="n">factor</span><span class="p">))</span>
        <span class="n">hop_length_STMSP</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">hop_length</span> <span class="o">/</span> <span class="n">factor</span><span class="p">))</span>

        <span class="c1"># filter the signal</span>
        <span class="n">cur_sr_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">y_srs</span> <span class="o">==</span> <span class="n">cur_sr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">flayout</span> <span class="o">==</span> <span class="s1">&#39;ba&#39;</span><span class="p">:</span>
            <span class="n">cur_filter_output</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">cur_filter</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cur_filter</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                      <span class="n">y_resampled</span><span class="p">[</span><span class="n">cur_sr_idx</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">flayout</span> <span class="o">==</span> <span class="s1">&#39;sos&#39;</span><span class="p">:</span>
            <span class="n">cur_filter_output</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">cur_filter</span><span class="p">,</span>
                                                         <span class="n">y_resampled</span><span class="p">[</span><span class="n">cur_sr_idx</span><span class="p">])</span>

        <span class="c1"># frame the current filter output</span>
        <span class="n">cur_frames</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">frame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">cur_filter_output</span><span class="p">),</span>
                                <span class="n">frame_length</span><span class="o">=</span><span class="n">win_length_STMSP</span><span class="p">,</span>
                                <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length_STMSP</span><span class="p">)</span>

        <span class="n">bands_power</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cur_frames</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:</span><span class="n">n_frames</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bands_power</span><span class="p">)</span></div>


<div class="viewcode-block" id="power_to_db"><a class="viewcode-back" href="../../../generated/librosa.core.power_to_db.html#librosa.core.power_to_db">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">power_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">amin</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">top_db</span><span class="o">=</span><span class="mf">80.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a power spectrogram (amplitude squared) to decibel (dB) units</span>

<span class="sd">    This computes the scaling ``10 * log10(S / ref)`` in a numerically</span>
<span class="sd">    stable way.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        input power</span>

<span class="sd">    ref : scalar or callable</span>
<span class="sd">        If scalar, the amplitude `abs(S)` is scaled relative to `ref`:</span>
<span class="sd">        `10 * log10(S / ref)`.</span>
<span class="sd">        Zeros in the output correspond to positions where `S == ref`.</span>

<span class="sd">        If callable, the reference value is computed as `ref(S)`.</span>

<span class="sd">    amin : float &gt; 0 [scalar]</span>
<span class="sd">        minimum threshold for `abs(S)` and `ref`</span>

<span class="sd">    top_db : float &gt;= 0 [scalar]</span>
<span class="sd">        threshold the output at `top_db` below the peak:</span>
<span class="sd">        ``max(10 * log10(S)) - top_db``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_db   : np.ndarray</span>
<span class="sd">        ``S_db ~= 10 * log10(S) - 10 * log10(ref)``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    perceptual_weighting</span>
<span class="sd">    db_to_power</span>
<span class="sd">    amplitude_to_db</span>
<span class="sd">    db_to_amplitude</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get a power spectrogram from a waveform ``y``</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.power_to_db(S**2)</span>
<span class="sd">    array([[-33.293, -27.32 , ..., -33.293, -33.293],</span>
<span class="sd">           [-33.293, -25.723, ..., -33.293, -33.293],</span>
<span class="sd">           ...,</span>
<span class="sd">           [-33.293, -33.293, ..., -33.293, -33.293],</span>
<span class="sd">           [-33.293, -33.293, ..., -33.293, -33.293]], dtype=float32)</span>

<span class="sd">    Compute dB relative to peak power</span>

<span class="sd">    &gt;&gt;&gt; librosa.power_to_db(S**2, ref=np.max)</span>
<span class="sd">    array([[-80.   , -74.027, ..., -80.   , -80.   ],</span>
<span class="sd">           [-80.   , -72.431, ..., -80.   , -80.   ],</span>
<span class="sd">           ...,</span>
<span class="sd">           [-80.   , -80.   , ..., -80.   , -80.   ],</span>
<span class="sd">           [-80.   , -80.   , ..., -80.   , -80.   ]], dtype=float32)</span>


<span class="sd">    Or compare to median power</span>

<span class="sd">    &gt;&gt;&gt; librosa.power_to_db(S**2, ref=np.median)</span>
<span class="sd">    array([[-0.189,  5.784, ..., -0.189, -0.189],</span>
<span class="sd">           [-0.189,  7.381, ..., -0.189, -0.189],</span>
<span class="sd">           ...,</span>
<span class="sd">           [-0.189, -0.189, ..., -0.189, -0.189],</span>
<span class="sd">           [-0.189, -0.189, ..., -0.189, -0.189]], dtype=float32)</span>


<span class="sd">    And plot the results</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(S**2, sr=sr, y_axis=&#39;log&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.power_to_db(S**2, ref=np.max),</span>
<span class="sd">    ...                          sr=sr, y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Log-Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">amin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;amin must be strictly positive&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;power_to_db was called on complex input so phase &#39;</span>
                      <span class="s1">&#39;information will be discarded. To suppress this warning, &#39;</span>
                      <span class="s1">&#39;call power_to_db(np.abs(D)**2) instead.&#39;</span><span class="p">)</span>
        <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">magnitude</span> <span class="o">=</span> <span class="n">S</span>

    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">ref</span><span class="p">):</span>
        <span class="c1"># User supplied a function to calculate reference power</span>
        <span class="n">ref_value</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="n">magnitude</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ref_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>

    <span class="n">log_spec</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">amin</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">))</span>
    <span class="n">log_spec</span> <span class="o">-=</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">amin</span><span class="p">,</span> <span class="n">ref_value</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">top_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">top_db</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;top_db must be non-negative&#39;</span><span class="p">)</span>
        <span class="n">log_spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">log_spec</span><span class="p">,</span> <span class="n">log_spec</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">top_db</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">log_spec</span></div>


<div class="viewcode-block" id="db_to_power"><a class="viewcode-back" href="../../../generated/librosa.core.db_to_power.html#librosa.core.db_to_power">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">db_to_power</span><span class="p">(</span><span class="n">S_db</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Convert a dB-scale spectrogram to a power spectrogram.</span>

<span class="sd">    This effectively inverts `power_to_db`:</span>

<span class="sd">        `db_to_power(S_db) ~= ref * 10.0**(S_db / 10)`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S_db : np.ndarray</span>
<span class="sd">        dB-scaled spectrogram</span>

<span class="sd">    ref : number &gt; 0</span>
<span class="sd">        Reference power: output will be scaled by this value</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        Power spectrogram</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">ref</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">S_db</span><span class="p">)</span></div>


<div class="viewcode-block" id="amplitude_to_db"><a class="viewcode-back" href="../../../generated/librosa.core.amplitude_to_db.html#librosa.core.amplitude_to_db">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">amplitude_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">amin</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">top_db</span><span class="o">=</span><span class="mf">80.0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Convert an amplitude spectrogram to dB-scaled spectrogram.</span>

<span class="sd">    This is equivalent to ``power_to_db(S**2)``, but is provided for convenience.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        input amplitude</span>

<span class="sd">    ref : scalar or callable</span>
<span class="sd">        If scalar, the amplitude `abs(S)` is scaled relative to `ref`:</span>
<span class="sd">        `20 * log10(S / ref)`.</span>
<span class="sd">        Zeros in the output correspond to positions where `S == ref`.</span>

<span class="sd">        If callable, the reference value is computed as `ref(S)`.</span>

<span class="sd">    amin : float &gt; 0 [scalar]</span>
<span class="sd">        minimum threshold for `S` and `ref`</span>

<span class="sd">    top_db : float &gt;= 0 [scalar]</span>
<span class="sd">        threshold the output at `top_db` below the peak:</span>
<span class="sd">        ``max(20 * log10(S)) - top_db``</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_db : np.ndarray</span>
<span class="sd">        ``S`` measured in dB</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    power_to_db, db_to_amplitude</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;amplitude_to_db was called on complex input so phase &#39;</span>
                      <span class="s1">&#39;information will be discarded. To suppress this warning, &#39;</span>
                      <span class="s1">&#39;call amplitude_to_db(np.abs(S)) instead.&#39;</span><span class="p">)</span>

    <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">ref</span><span class="p">):</span>
        <span class="c1"># User supplied a function to calculate reference power</span>
        <span class="n">ref_value</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="n">magnitude</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ref_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>

    <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">magnitude</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">magnitude</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">ref_value</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">amin</span><span class="o">=</span><span class="n">amin</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                       <span class="n">top_db</span><span class="o">=</span><span class="n">top_db</span><span class="p">)</span></div>


<div class="viewcode-block" id="db_to_amplitude"><a class="viewcode-back" href="../../../generated/librosa.core.db_to_amplitude.html#librosa.core.db_to_amplitude">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">db_to_amplitude</span><span class="p">(</span><span class="n">S_db</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Convert a dB-scaled spectrogram to an amplitude spectrogram.</span>

<span class="sd">    This effectively inverts `amplitude_to_db`:</span>

<span class="sd">        `db_to_amplitude(S_db) ~= 10.0**(0.5 * (S_db + log10(ref)/10))`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S_db : np.ndarray</span>
<span class="sd">        dB-scaled spectrogram</span>

<span class="sd">    ref: number &gt; 0</span>
<span class="sd">        Optional reference power.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        Linear magnitude spectrogram</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">db_to_power</span><span class="p">(</span><span class="n">S_db</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">ref</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span></div>


<div class="viewcode-block" id="perceptual_weighting"><a class="viewcode-back" href="../../../generated/librosa.core.perceptual_weighting.html#librosa.core.perceptual_weighting">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">perceptual_weighting</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Perceptual weighting of a power spectrogram:</span>

<span class="sd">    `S_p[f] = A_weighting(f) + 10*log(S[f] / ref)`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray [shape=(d, t)]</span>
<span class="sd">        Power spectrogram</span>

<span class="sd">    frequencies : np.ndarray [shape=(d,)]</span>
<span class="sd">        Center frequency for each row of `S`</span>

<span class="sd">    kwargs : additional keyword arguments</span>
<span class="sd">        Additional keyword arguments to `power_to_db`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_p : np.ndarray [shape=(d, t)]</span>
<span class="sd">        perceptually weighted version of `S`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    power_to_db</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Re-weight a CQT power spectrum, using peak power as reference</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; C = np.abs(librosa.cqt(y, sr=sr, fmin=librosa.note_to_hz(&#39;A1&#39;)))</span>
<span class="sd">    &gt;&gt;&gt; freqs = librosa.cqt_frequencies(C.shape[0],</span>
<span class="sd">    ...                                 fmin=librosa.note_to_hz(&#39;A1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; perceptual_CQT = librosa.perceptual_weighting(C**2,</span>
<span class="sd">    ...                                               freqs,</span>
<span class="sd">    ...                                               ref=np.max)</span>
<span class="sd">    &gt;&gt;&gt; perceptual_CQT</span>
<span class="sd">    array([[ -80.076,  -80.049, ..., -104.735, -104.735],</span>
<span class="sd">           [ -78.344,  -78.555, ..., -103.725, -103.725],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ -76.272,  -76.272, ...,  -76.272,  -76.272],</span>
<span class="sd">           [ -76.485,  -76.485, ...,  -76.485,  -76.485]])</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(C,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          fmin=librosa.note_to_hz(&#39;A1&#39;),</span>
<span class="sd">    ...                          y_axis=&#39;cqt_hz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Log CQT power&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(perceptual_CQT, y_axis=&#39;cqt_hz&#39;,</span>
<span class="sd">    ...                          fmin=librosa.note_to_hz(&#39;A1&#39;),</span>
<span class="sd">    ...                          x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Perceptually weighted log CQT&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">offset</span> <span class="o">=</span> <span class="n">time_frequency</span><span class="o">.</span><span class="n">A_weighting</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="fmt"><a class="viewcode-back" href="../../../generated/librosa.core.fmt.html#librosa.core.fmt">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fmt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">n_fmt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">over_sample</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The fast Mellin transform (FMT) [1]_ of a uniformly sampled signal y.</span>

<span class="sd">    When the Mellin parameter (beta) is 1/2, it is also known as the scale transform [2]_.</span>
<span class="sd">    The scale transform can be useful for audio analysis because its magnitude is invariant</span>
<span class="sd">    to scaling of the domain (e.g., time stretching or compression).  This is analogous</span>
<span class="sd">    to the magnitude of the Fourier transform being invariant to shifts in the input domain.</span>


<span class="sd">    .. [1] De Sena, Antonio, and Davide Rocchesso.</span>
<span class="sd">        &quot;A fast Mellin and scale transform.&quot;</span>
<span class="sd">        EURASIP Journal on Applied Signal Processing 2007.1 (2007): 75-75.</span>

<span class="sd">    .. [2] Cohen, L.</span>
<span class="sd">        &quot;The scale representation.&quot;</span>
<span class="sd">        IEEE Transactions on Signal Processing 41, no. 12 (1993): 3275-3292.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray, real-valued</span>
<span class="sd">        The input signal(s).  Can be multidimensional.</span>
<span class="sd">        The target axis must contain at least 3 samples.</span>

<span class="sd">    t_min : float &gt; 0</span>
<span class="sd">        The minimum time spacing (in samples).</span>
<span class="sd">        This value should generally be less than 1 to preserve as much information as</span>
<span class="sd">        possible.</span>

<span class="sd">    n_fmt : int &gt; 2 or None</span>
<span class="sd">        The number of scale transform bins to use.</span>
<span class="sd">        If None, then `n_bins = over_sample * ceil(n * log((n-1)/t_min))` is taken,</span>
<span class="sd">        where `n = y.shape[axis]`</span>

<span class="sd">    kind : str</span>
<span class="sd">        The type of interpolation to use when re-sampling the input.</span>
<span class="sd">        See `scipy.interpolate.interp1d` for possible values.</span>

<span class="sd">        Note that the default is to use high-precision (cubic) interpolation.</span>
<span class="sd">        This can be slow in practice; if speed is preferred over accuracy,</span>
<span class="sd">        then consider using `kind=&#39;linear&#39;`.</span>

<span class="sd">    beta : float</span>
<span class="sd">        The Mellin parameter.  `beta=0.5` provides the scale transform.</span>

<span class="sd">    over_sample : float &gt;= 1</span>
<span class="sd">        Over-sampling factor for exponential resampling.</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to transform `y`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_scale : np.ndarray [dtype=complex]</span>
<span class="sd">        The scale transform of `y` along the `axis` dimension.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        if `n_fmt &lt; 2` or `t_min &lt;= 0`</span>
<span class="sd">        or if `y` is not finite</span>
<span class="sd">        or if `y.shape[axis] &lt; 3`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Generate a signal and time-stretch it (with energy normalization)</span>
<span class="sd">    &gt;&gt;&gt; scale = 1.25</span>
<span class="sd">    &gt;&gt;&gt; freq = 3.0</span>
<span class="sd">    &gt;&gt;&gt; x1 = np.linspace(0, 1, num=1024, endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; x2 = np.linspace(0, 1, num=scale * len(x1), endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; y1 = np.sin(2 * np.pi * freq * x1)</span>
<span class="sd">    &gt;&gt;&gt; y2 = np.sin(2 * np.pi * freq * x2) / np.sqrt(scale)</span>
<span class="sd">    &gt;&gt;&gt; # Verify that the two signals have the same energy</span>
<span class="sd">    &gt;&gt;&gt; np.sum(np.abs(y1)**2), np.sum(np.abs(y2)**2)</span>
<span class="sd">        (255.99999999999997, 255.99999999999969)</span>
<span class="sd">    &gt;&gt;&gt; scale1 = librosa.fmt(y1, n_fmt=512)</span>
<span class="sd">    &gt;&gt;&gt; scale2 = librosa.fmt(y2, n_fmt=512)</span>
<span class="sd">    &gt;&gt;&gt; # And plot the results</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(8, 4))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 1)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(y1, label=&#39;Original&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(y2, linestyle=&#39;--&#39;, label=&#39;Stretched&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;time (samples)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Input signals&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogy(np.abs(scale1), label=&#39;Original&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogy(np.abs(scale2), linestyle=&#39;--&#39;, label=&#39;Stretched&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;scale coefficients&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Scale transform magnitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &gt;&gt;&gt; # Plot the scale transform of an onset strength autocorrelation</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(),</span>
<span class="sd">    ...                      offset=10.0, duration=30.0)</span>
<span class="sd">    &gt;&gt;&gt; odf = librosa.onset.onset_strength(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; # Auto-correlate with up to 10 seconds lag</span>
<span class="sd">    &gt;&gt;&gt; odf_ac = librosa.autocorrelate(odf, max_size=10 * sr // 512)</span>
<span class="sd">    &gt;&gt;&gt; # Normalize</span>
<span class="sd">    &gt;&gt;&gt; odf_ac = librosa.util.normalize(odf_ac, norm=np.inf)</span>
<span class="sd">    &gt;&gt;&gt; # Compute the scale transform</span>
<span class="sd">    &gt;&gt;&gt; odf_ac_scale = librosa.fmt(librosa.util.normalize(odf_ac), n_fmt=512)</span>
<span class="sd">    &gt;&gt;&gt; # Plot the results</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(odf, label=&#39;Onset strength&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Time (frames)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(odf_ac, label=&#39;Onset autocorrelation&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Lag (frames)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 1, 3)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogy(np.abs(odf_ac_scale), label=&#39;Scale transform magnitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;scale coefficients&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;y.shape[</span><span class="si">{:}</span><span class="s1">]==</span><span class="si">{:}</span><span class="s1"> &lt; 3&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">t_min</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;t_min must be a positive number&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_fmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">over_sample</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;over_sample must be &gt;= 1&#39;</span><span class="p">)</span>

        <span class="c1"># The base is the maximum ratio between adjacent samples</span>
        <span class="c1"># Since the sample spacing is increasing, this is simply the</span>
        <span class="c1"># ratio between the positions of the last two samples: (n-1)/(n-2)</span>
        <span class="n">log_base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">n_fmt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">over_sample</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">t_min</span><span class="p">))</span> <span class="o">/</span> <span class="n">log_base</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">n_fmt</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;n_fmt==</span><span class="si">{:}</span><span class="s1"> &lt; 3&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_fmt</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n_fmt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n_fmt</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">over_sample</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;y must be finite everywhere&#39;</span><span class="p">)</span>

    <span class="n">base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_base</span><span class="p">)</span>
    <span class="c1"># original grid: signal covers [0, 1).  This range is arbitrary, but convenient.</span>
    <span class="c1"># The final sample is positioned at (n-1)/n, so we omit the endpoint</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># build the interpolator</span>
    <span class="n">f_interp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="c1"># build the new sampling grid</span>
    <span class="c1"># exponentially spaced between t_min/n and 1 (exclusive)</span>
    <span class="c1"># we&#39;ll go one past where we need, and drop the last sample</span>
    <span class="c1"># When over-sampling, the last input sample contributions n_over samples.</span>
    <span class="c1"># To keep the spacing consistent, we over-sample by n_over, and then</span>
    <span class="c1"># trim the final samples.</span>
    <span class="n">n_over</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">over_sample</span><span class="p">))</span>
    <span class="n">x_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">t_min</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">/</span> <span class="n">log_base</span><span class="p">,</span>
                        <span class="mi">0</span><span class="p">,</span>
                        <span class="n">num</span><span class="o">=</span><span class="n">n_fmt</span> <span class="o">+</span> <span class="n">n_over</span><span class="p">,</span>
                        <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">)[:</span><span class="o">-</span><span class="n">n_over</span><span class="p">]</span>

    <span class="c1"># Clean up any rounding errors at the boundaries of the interpolation</span>
    <span class="c1"># The interpolator gets angry if we try to extrapolate, so clipping is necessary here.</span>
    <span class="k">if</span> <span class="n">x_exp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">t_min</span> <span class="ow">or</span> <span class="n">x_exp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">x_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">x_exp</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">t_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Make sure that all sample points are unique</span>
    <span class="c1"># This should never happen!</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x_exp</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_exp</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Redundant sample positions in Mellin transform&#39;</span><span class="p">)</span>

    <span class="c1"># Resample the signal</span>
    <span class="n">y_res</span> <span class="o">=</span> <span class="n">f_interp</span><span class="p">(</span><span class="n">x_exp</span><span class="p">)</span>

    <span class="c1"># Broadcast the window correctly</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y_res</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Apply the window and fft</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">y_res</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_exp</span><span class="o">**</span><span class="n">beta</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span>
                     <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">overwrite_x</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Slice out the positive-scale component</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">idx</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n_fmt</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Truncate and length-normalize</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_fmt</span></div>


<div class="viewcode-block" id="pcen"><a class="viewcode-back" href="../../../generated/librosa.core.pcen.html#librosa.core.pcen">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">pcen</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="mf">0.98</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
         <span class="n">time_constant</span><span class="o">=</span><span class="mf">0.400</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
         <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Per-channel energy normalization (PCEN) [1]_</span>

<span class="sd">    This function normalizes a time-frequency representation `S` by</span>
<span class="sd">    performing automatic gain control, followed by nonlinear compression:</span>

<span class="sd">        P[f, t] = (S / (eps + M[f, t])**gain + bias)**power - bias**power</span>

<span class="sd">    where `M` is the result of applying a low-pass, temporal IIR filter</span>
<span class="sd">    to `S`:</span>

<span class="sd">        M[f, t] = (1 - b) * M[f, t - 1] + b * S[f, t]</span>

<span class="sd">    If `b` is not provided, it is calculated as:</span>

<span class="sd">        b = (sqrt(1 + 4* T**2) - 1) / (2 * T**2)</span>

<span class="sd">    where `T = time_constant * sr / hop_length`.</span>

<span class="sd">    This normalization is designed to suppress background noise and</span>
<span class="sd">    emphasize foreground signals, and can be used as an alternative to</span>
<span class="sd">    decibel scaling (`amplitude_to_db`).</span>

<span class="sd">    This implementation also supports smoothing across frequency bins</span>
<span class="sd">    by specifying `max_size &gt; 1`.  If this option is used, the filtered</span>
<span class="sd">    spectrogram `M` is computed as</span>

<span class="sd">        M[f, t] = (1 - b) * M[f, t - 1] + b * R[f, t]</span>

<span class="sd">    where `R` has been max-filtered along the frequency axis, similar to</span>
<span class="sd">    the SuperFlux algorithm implemented in `onset.onset_strength`:</span>

<span class="sd">        R[f, t] = max(S[f - max_size//2: f + max_size//2, t])</span>

<span class="sd">    This can be used to perform automatic gain control on signals that cross</span>
<span class="sd">    or span multiple frequency bans, which may be desirable for spectrograms</span>
<span class="sd">    with high frequency resolution.</span>

<span class="sd">    .. [1] Wang, Y., Getreuer, P., Hughes, T., Lyon, R. F., &amp; Saurous, R. A.</span>
<span class="sd">       (2017, March). Trainable frontend for robust and far-field keyword spotting.</span>
<span class="sd">       In Acoustics, Speech and Signal Processing (ICASSP), 2017</span>
<span class="sd">       IEEE International Conference on (pp. 5670-5674). IEEE.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray (non-negative)</span>
<span class="sd">        The input (magnitude) spectrogram</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        The audio sampling rate</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        The hop length of `S`, expressed in samples</span>

<span class="sd">    gain : number &gt;= 0 [scalar]</span>
<span class="sd">        The gain factor.  Typical values should be slightly less than 1.</span>

<span class="sd">    bias : number &gt;= 0 [scalar]</span>
<span class="sd">        The bias point of the nonlinear compression (default: 2)</span>

<span class="sd">    power : number &gt; 0 [scalar]</span>
<span class="sd">        The compression exponent.  Typical values should be between 0 and 1.</span>
<span class="sd">        Smaller values of `power` result in stronger compression.</span>

<span class="sd">    time_constant : number &gt; 0 [scalar]</span>
<span class="sd">        The time constant for IIR filtering, measured in seconds.</span>

<span class="sd">    eps : number &gt; 0 [scalar]</span>
<span class="sd">        A small constant used to ensure numerical stability of the filter.</span>

<span class="sd">    b : number in [0, 1]  [scalar]</span>
<span class="sd">        The filter coefficient for the low-pass filter.</span>
<span class="sd">        If not provided, it will be inferred from `time_constant`.</span>

<span class="sd">    max_size : int &gt; 0 [scalar]</span>
<span class="sd">        The width of the max filter applied to the frequency axis.</span>
<span class="sd">        If left as `1`, no filtering is performed.</span>

<span class="sd">    ref : None or np.ndarray (shape=S.shape)</span>
<span class="sd">        An optional pre-computed reference spectrum (`R` in the above).</span>
<span class="sd">        If not provided it will be computed from `S`.</span>

<span class="sd">    axis : int [scalar]</span>
<span class="sd">        The (time) axis of the input spectrogram.</span>

<span class="sd">    max_axis : None or int [scalar]</span>
<span class="sd">        The frequency axis of the input spectrogram.</span>
<span class="sd">        If `None`, and `S` is two-dimensional, it will be inferred</span>
<span class="sd">        as the opposite from `axis`.</span>
<span class="sd">        If `S` is not two-dimensional, and `max_size &gt; 1`, an error</span>
<span class="sd">        will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P : np.ndarray, non-negative [shape=(n, m)]</span>
<span class="sd">        The per-channel energy normalized version of `S`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    amplitude_to_db</span>
<span class="sd">    librosa.onset.onset_strength</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Compare PCEN to log amplitude (dB) scaling on Mel spectra</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(),</span>
<span class="sd">    ...                      offset=10, duration=10)</span>

<span class="sd">    &gt;&gt;&gt; # We&#39;ll use power=1 to get a magnitude spectrum</span>
<span class="sd">    &gt;&gt;&gt; # instead of a power spectrum</span>
<span class="sd">    &gt;&gt;&gt; S = librosa.feature.melspectrogram(y, sr=sr, power=1)</span>
<span class="sd">    &gt;&gt;&gt; log_S = librosa.amplitude_to_db(S, ref=np.max)</span>
<span class="sd">    &gt;&gt;&gt; pcen_S = librosa.pcen(S)</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(log_S, x_axis=&#39;time&#39;, y_axis=&#39;mel&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;log amplitude (dB)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(pcen_S, x_axis=&#39;time&#39;, y_axis=&#39;mel&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Per-channel energy normalization&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    Compare PCEN with and without max-filtering</span>

<span class="sd">    &gt;&gt;&gt; pcen_max = librosa.pcen(S, max_size=3)</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(pcen_S, x_axis=&#39;time&#39;, y_axis=&#39;mel&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Per-channel energy normalization (no max-filter)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(pcen_max, x_axis=&#39;time&#39;, y_axis=&#39;mel&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Per-channel energy normalization (max_size=3)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">power</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;power=</span><span class="si">{}</span><span class="s1"> must be strictly positive&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">power</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">gain</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;gain=</span><span class="si">{}</span><span class="s1"> must be non-negative&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gain</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">bias</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;bias=</span><span class="si">{}</span><span class="s1"> must be non-negative&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bias</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">eps</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;eps=</span><span class="si">{}</span><span class="s1"> must be strictly positive&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">eps</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">time_constant</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;time_constant=</span><span class="si">{}</span><span class="s1"> must be strictly positive&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_constant</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">max_size</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;max_size=</span><span class="si">{}</span><span class="s1"> must be a positive integer&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_size</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t_frames</span> <span class="o">=</span> <span class="n">time_constant</span> <span class="o">*</span> <span class="n">sr</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">hop_length</span><span class="p">)</span>
        <span class="c1"># By default, this solves the equation for b:</span>
        <span class="c1">#   b**2  + (1 - b) / t_frames  - 2 = 0</span>
        <span class="c1"># which approximates the full-width half-max of the</span>
        <span class="c1"># squared frequency response of the IIR low-pass filter</span>

        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">t_frames</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">t_frames</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;b=</span><span class="si">{}</span><span class="s1"> must be between 0 and 1&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;pcen was called on complex input so phase &#39;</span>
                      <span class="s1">&#39;information will be discarded. To suppress this warning, &#39;</span>
                      <span class="s1">&#39;call pcen(np.abs(D)) instead.&#39;</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">max_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">S</span>
        <span class="k">elif</span> <span class="n">S</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Max-filtering cannot be applied to 1-dimensional input&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">max_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Max-filtering a </span><span class="si">{:d}</span><span class="s1">-dimensional spectrogram &#39;</span>
                                         <span class="s1">&#39;requires you to specify max_axis&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
                <span class="c1"># if axis = 0, max_axis=1</span>
                <span class="c1"># if axis = +- 1, max_axis = 0</span>
                <span class="n">max_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">ref</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">maximum_filter1d</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">max_size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">max_axis</span><span class="p">)</span>

    <span class="n">S_smooth</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">([</span><span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ref</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Working in log-space gives us some stability, and a slight speedup</span>
    <span class="n">smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">gain</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">S_smooth</span> <span class="o">/</span> <span class="n">eps</span><span class="p">)))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="n">smooth</span> <span class="o">+</span> <span class="n">bias</span><span class="p">)</span><span class="o">**</span><span class="n">power</span> <span class="o">-</span> <span class="n">bias</span><span class="o">**</span><span class="n">power</span></div>


<span class="k">def</span> <span class="nf">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Helper function to retrieve a magnitude spectrogram.</span>

<span class="sd">    This is primarily used in feature extraction functions that can operate on</span>
<span class="sd">    either audio time-series or spectrogram input.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : None or np.ndarray [ndim=1]</span>
<span class="sd">        If provided, an audio time series</span>

<span class="sd">    S : None or np.ndarray</span>
<span class="sd">        Spectrogram input, optional</span>

<span class="sd">    n_fft : int &gt; 0</span>
<span class="sd">        STFT window size</span>

<span class="sd">    hop_length : int &gt; 0</span>
<span class="sd">        STFT hop length</span>

<span class="sd">    power : float &gt; 0</span>
<span class="sd">        Exponent for the magnitude spectrogram,</span>
<span class="sd">        e.g., 1 for energy, 2 for power, etc.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_out : np.ndarray [dtype=np.float32]</span>
<span class="sd">        - If `S` is provided as input, then `S_out == S`</span>
<span class="sd">        - Else, `S_out = |stft(y, n_fft=n_fft, hop_length=hop_length)|**power`</span>

<span class="sd">    n_fft : int &gt; 0</span>
<span class="sd">        - If `S` is provided, then `n_fft` is inferred from `S`</span>
<span class="sd">        - Else, copied from input</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Infer n_fft from spectrogram shape</span>
        <span class="n">n_fft</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Otherwise, compute a magnitude spectrogram from input</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">))</span><span class="o">**</span><span class="n">power</span>

    <span class="k">return</span> <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2013--2020, librosa development team

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: 0.6.3
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Tags</dt>
      <dd><a href="spectrum.html">0.6.3</a></dd>
      <dd><a href="../../../../0.7.0/index.html">0.7.0</a></dd>
      <dd><a href="../../../../0.7.1/index.html">0.7.1</a></dd>
      <dd><a href="../../../../0.7.2/index.html">0.7.2</a></dd>
    </dl>
    <dl>
      <dt>Branches</dt>
      <dd><a href="../../../../doc-audit-0.8/index.html">doc-audit-0.8</a></dd>
      <dd><a href="../../../../main/index.html">main</a></dd>
    </dl>
  </div>
</div>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-171031946-1', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>